\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{physics}

\usepackage[paperheight=16cm,paperwidth=14cm,textwidth=12cm]{geometry}
\usepackage{parskip}
\linespread{0.8} % si c'est trop proche, personnellement je peux me perdre dans les lignes
\setlength{\parskip}{15pt plus2pt} % si j'écris en paragraphe, je veux qu'on puisse voir ces paragraphes

\usepackage[french]{babel}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}


\SetKwInput{KwInput}{Entrée}
\SetKwInput{KwOutput}{Sortie}


\author{Stephane LEJEUNE, Jacques PHAM BA NIEN} % ajouter vos prénoms/noms
\title{Projet de Simulateur de Fluide}


\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduction}

Pour le projet, nous avons choisis de construire un simulateur de fluide, projet non proposé de base, mais c'est un projet que Stephane et Jacques voulaient déjà faire depuis la L2, nous avons donc proposer le projet et il a été accepté.

Étant en double licence, le style de compétences utiles qu'on peut apprendre avec un projet informatique sont différentes, le projet de simulateur de fluide nous a sembler être un bon compromis entre demandant des compétences informatiques et mathématiques. 

Ce projet, nous permet d'explorer comment les techniques qu'on as appris durant différent cours analyse numériques peuvent être utiliser pour quelque chose de plus ``réel'' (et visuel) que résoudre un système linéaire ou des équations différentiels abstraites.

Du point de vu informatique, ce projet nous oblige à interagir avec une interface graphique, choisir nos structures pour representer les particules (ou ne pas les representer)

Nous sommes donc reconnaissant que notre proposition de projet ait été accepté.

L'objectif du projet est double:
\begin{enumerate}
    \item Implémenter une simulation de fluide stable, visuellement cohérente, et intéractive, capable de gérer plusieurs centaintes, voire mileirs de particules.
    \item Intégrer cette simulation dans un moteur de jeu 2D, en l'occurrence, {\emph {Unity}}, pour permettre une visualisation en temps réel avec un contrôle sur les paramètres physiques.
\end{enumerate}

Durant le développement, de nombreux défis ont été rencontrés: gestion des densités divergentes, explosions numériques liées à une mauvaise évaluation de la pression, instabilités aux frontières, ou encore des performances non optimales à partir d'un certain nombre de particules. Plusieurs améliorations progressives ont été apportés, incluant l'ajout d'une grille spatiale, la prédiction de position, un modèle de pression stable (Tait), et une modélisation simplifiée de la viscosité.

Ce rapport détaille les fondements physiques du modèles SPH, la manière dont il a été implémenté,optimisé et visualié dans Unity, ansi que les résultats obtenus, leurs limites et des pistes d'améliorations futures.

\section{Théorie de simulateur de fluide}
\subsection{Equation de Navier-Stokes}
Pour comprendre comment un simulateur de fluide marchent, il nous as d'abord fallu comprendre comment un fluide est sensé se comporter.

On as certes un modèle en nous de comment cela fonctionne, on a déjà vu des fluides, mais transmettre cette intuition en instructions est loins d'être facile, cela n'est pas notre travail, c'est celui des physiciens. Nous avons donc regarder à comment les physiciens décrivent les lois que les fluides doivent respecter.

Déjà, un ``fluide'' en physique ne décrit pas seulement le comportement d'un liquide, cela décrit aussi le comportement des gas, leurs comportement sont étudier dans la ``mécanique des fluides''.

Ses lois sont appeler ``équations de Navier-Stokes'':

\begin{enumerate}
    \item Équation de continuité:
        \[
            \grad \cdot \vec{V} = 0
        \]
    \item Équation de moments:
        \[
            \rho (\pdv{\vec{V}}{t} + \vec{V}\cdot \grad \vec{V}) = - \grad p  + \mu \grad ^ 2 \vec{V} + \vec{F}
        \]
\end{enumerate}

L'équation de continuité nous dit que l'énergie mécanique du fluide ne change pas avec le temps (sa dérivé est nulle).

L'équation de moments est plus complexe, elle décrit les forces locales qui sont exercé sur notre fluide, décortiquons ce que veut dire chaque termes:

\begin{itemize}
    \item \(\rho\) est la densité (locale, mais cela n'importe peu pour la suite) de notre fluide, donc c'est la masse divisé par le volume autour d'un point.
    \item \(\vec{F}\) est la force externe exercé sur notre fluide, ici c'est juste la gravité. La force exercé par la gravité localement est \(\vec{g} \frac{m}{V}\) où \(\vec{g}\) est la force gravitationnel universelle, \(m\) est la masse et \(V\) est le volume. Autrement dit: 
        \[\vec{F} = \rho\vec{g}\].
    \item \(\vec{V}\) est le champ vectoriel de la vitesse du fluide. Champ vectoriel car en tout point, le vecteur direction peut être différent.
    \item \(p\) est la pression du fluide.
    \item \(\mu\) est une constante propre au fluide étudié, cela modèle la viscosité, plus elle est grande, plus le fluide est visqueux, ce terme limite l'accélaration.
\end{itemize}

Cette équation nous dit donc que le changement de vitesse locale est du aux forces extérieurs, et à la différences de vitesse environnantes, en évitant de trop se compresser, et n'accélérant pas trop vite proportionnelement à la constante de viscosité.

Tout du long, nous allons simplifier notre fluide étudier, en général, les fluides dont on s'intéresse (surtout l'eau) ne sont pas visqueux (nous rajouterons la viscosité plus tard pour des raisons de précision numériques, mais ignorons ce paramètre pour l'instant), et aussi (quasiment) incompréssible, cela simplifie nos équations, ce qui rends la simulation plus simple et plus rapide, nos nouvelles équations:

\begin{itemize}
    \item Conservation:
        \[
            \grad \cdot \vec{V} = 0
        \]
    \item Incompréssible:
        \[
            \grad p = 0
        \]
    \item Moments:
        \[
            \pdv{\vec{V}}{t} = \vec{g} - \vec{V} \cdot \grad \vec{V}
        \]
\end{itemize}

\subsection{Simulateurs}

Certes maintenant on a ``comment les fluides doivent agir'', on n'a pas ``comment les faire agir comme tel''.

Pour observer la vie réel, cela n'a pas d'importance, pour un mathématicien non plus, mais un ordinateur de peut pas gérer des équations différentiels de manière exactes sur un volume continu, il y aurait juste beaucoup trop de données à stoquer et de calcul à faire (même, une infinité non dénombrable, d'où cette incapacité).

Ainsi, on est obliger de simplifier notre tache, au lieu d'obtenir un système agissant {\emph {exactement}} comme un fluide idéal, il faut faire un système qui agit {\emph {approximativement}} comme un fluide idéal, les physiciens font déjà cela pour simplifier les calculs (nous ne faisons pas en général de la théories des probabilités et des équations depuis le quantique pour des fluides, car il y aurait trop de termes agissant entre eux, obscursissant les calculs, et même pourrait rendre des équations insolvables de manière numériques), en informatique, nous allons passer du continu au discret, perdant ainsi de la précision pour en échange, avoir de la possibilité et de la vitesse de calcul.

Il y a plusieurs manières de discrétiser notre problème:

\subsubsection{Simulateur Newtonien}

On peut discretiser notre problème en considérant d'avoir une grille de vecteurs au lieu d'un champs, nous appellons chaques éléménts de la grille une ``boîte'' pour des raisons de facilité de visualisation.

Ainsi, il faut modeler la quantité de fluide passant d'une boîte à ses boites voisinnes.

Nous avons seulement besoin de modéliser le passage de fluide d'une boîte à ses voisinnes directes dans les directions de gauche, droite, haut et bas, pas besoin des diagonales.

Ainsi, une optimisation est de sauvegarder les magnitudes de ces flux au lieu de la magnitude et direction du flux partant du centre de la boîte.

En pseudocode, le calcul du flux ressemble à ça:

\begin{algorithm}
    \caption{Simulation de Newton}
\KwInput{grille}
\KwOutput{Même grille}
\For{boîte dans grille} {
    Ajout flux de boîte à la boîte en dessous\;
}
Mettre\_pression\_à\_zero(grille)\;
\end{algorithm}

Pour fixer la pression (faire que le flux en entré et en sortie de toutes boîtes est à 0), une approche (Gauss-Seidel) est de fixer la pression  de chaque boîte un par un, cela va defixer nos boîte fixé auparavent, mais en répétant cette opération, on converge vers la bonne solution (car la matrice associé à une diagonale dominante, mais ici la démonstration importe peu).

Appelons \(s(i, j)\) la ``facilité'' à pousser le flux de \(i\) vers \(j\) (par exemple, peut être mis à 0 pour représenter que \(j\) est un mur, permet aussi de mettre en contacte des fluides plus dense, etc.), on peut alors faire:

\begin{algorithm}
    \caption{Mettre pression à zero Newton}
    \KwInput{grille, nombreÉtapes et \(s\)}
    \KwOutput{Même grille}
    étape = 0 \;
    \While{étape < nombreÉtapes}{
        \For{boîte dans grille} {
            d = 0 \;
            flux = 0 \;
            \For{voisin dans voisins de boîte} {
                d = d + s(boîte, voisin) \;
                flux = flux + flux\_entre(boîte, voisin) * s(boîte, voisin)\;
            }
            \For{voisin dans voisins de boîte} {
                flux\_entre(boîte, voisin) -= flux * s(boîte, voisin) / d \;
            }
        }
    }
\end{algorithm}

Pour des raisons de performances, si il n'y a pas beaucoup de flux, il est également possible de mettre plusieurs boîte ensembles, de manière à ne plus avoir de grille, et se focaliser sur les endroits où il y a le plus d'actions (ce sont les endroits les plus important niveau comportement), il faudra alors changer le \(s\), une autre raison pour laquel avoir \(s\) est pratique.

\subsubsection{Simulateur Lagrangien}

Une autre approche est  de discretiser notre problème en une manière plus intuitive, en simulant nos {\emph {particules}} d'eaux, néanmoins, dans un fluide usuel, il y a beaucoup trop de particules, donc à la place, on va simuler des très grosses particules, ce qui est absurde physiquement mais marche relativement bien.

L'approche Lagrangienne permet de ne pas avoir à considerer que tout notre environement est dans un fluide, par exemple ne pas avoir à considerer à la foix l'eau {\emph {et}} l'air qui l'alentour.

Cette approche est plus proche de comment on intuitionne les fluides, mais plus loins du calcul mathématique que nous avons dérivé, il faut donc travailler avec des calcules plus complexe pour obtenir des valeurs tel que la vitesse, la température ou même la pression, ce problème de pression impacte de manière directe les performances, car on a généralement besoin de cette valeur pour simuler un fluide (à moins qu'on ait un grain très fin, alors les collisions entre particules génèrent d'elles même avec haute probabilités, des intéractions faisant penser à celle de la densité, en effet, un ``fluide'' n'est qu'un amas de beaucoup de particules intéragissant localement entre elles, notre comportement idéal n'est que le résultat probabiliste moyen que ces intéractions créent à grande échelle, sujet étudier en Physique Statistique).

Les soucis d'implémentation d'une méthode Lagrangienne sera expliquer plus tard (le simulateur SPH (Smoothed Paricle Hydrodynamics)) en détail, nous laissons donc cette sous section sans.

Néanmoins, ce qu'une approche Lagrangienne permet de faire, est de prendre un simulateur physique d'intéraction de corps usuel, et directement avoir nos fluides ``gratuitement''.

Cela permet aussi de l'étendre plus facilement, en effet, nous avons déjà l'intéraction entre petites particules, avec moins d'effort qu'avec une méthode Eulerienne, nous pouvons rajouter l'interaction de ces particules sur des objets de grande tailles.

\subsubsection{Simulateur Mixtes}

Tout comme vous avez pus le remarquer, les approches Newtoniennes et Lagrangiennes sont très différentes, et ont des bénéfices et des inconvénients.

Ce qui laisse la possibilité de mixer ces deux approches pour essayer de combler les inconvénients de chaques méthodes par l'autre.

Néanmoins, cette approche demande de gros efforts d'implémentation, beaucoup de test car il y a beaucoup plus de facteurs mouvants dans le système, pour des effets sur la performances qu'on peut obtenir en choississant un système et l'optimisation bien avec le même effort (mais un système mixte et optimisé pourrait être plus rapide).

\subsubsection{Simulateur SPH (Smoothed Paricle Hydrodynamics)}

C'est le simulateur que nous avons décider d'implémenté, nous avons d'abord penché sur une approche Newtonienne pour des raisons de simplicité, mais cette approche nous permets d'explorer plus de choses, sans non plus être incroyablement complexe niveau théorique ou pratique.

\subsubsection{Repréentation des particules}

Chaque particules sont caractérisées par:

\begin{itemize}
    \item un vecteur position \(\vec{r}\) (le \(p\) est déjà pris pour la pression)
    \item un vecteur vitesse \(\vec{v}\)
    \item une densité \(\rho\)
    \item une pression \(p\)
\end{itemize}

Chaque particule possède également une masse \(m\) partagé avec les autres particules, choisi de manière à respecter la masse total du fluide.

\subsubsection{Fonction de lissage (Kernel)}

L'originalité de SPH repose sur l'utilisation d'un noyau de lissage \(W(r, h)\), une fonction radiale (ne dépendant seulement de la distance) pondérant l'influence d'une particule en fonction de la distance \(r = \norm{\vec{r}_i - \vec{r}_j}\) entre les particules \(i\) et \(j\) (on impose aussi \(\vec{r}_i \ne \vec{r}_j\)), définit par:
\[ W(r, h) = \begin{cases}
        \frac{4}{\pi h^3}(h-r)^2 & \text{si}\, r < h \\
        0 & \text{sinon}
    \end{cases}
\]

On a que pour n'importe quel grandeux physique \(A\) sur un point (n'étant pas forcément une particule), on peut l'approximer par:

\[
    A(\vec{r}) = \sum_{i} m_i \frac{A_i}{\rho_i} W(\norm{\vec{r} - \vec{r_i}}, h)
\]

où \(A_i\) est cette grandeur à la particule \(i\).

Sa dérivé spatiale est également utilisée pour calculer les forces de pression, avec \(r < h\):

\[
    \grad W(r, h) = -\frac{8}{\pi h^3}(h - r)\frac{\vec{r}}{r}
\]

\subsubsection{Calcul de densité}

La densité locale \(\rho_i\) est estimée à partir des particules voisines:

\[
    \rho_i = \sum_j m_j W(\norm{\vec{r_i} - \vec{r_j}}, h)
\]

Ce qui fait sens physiquement, une masse pondéré par le volume du voisinage.

\subsubsection{Modèle de pression - Équation de Tait}

Afin de stabiliser et d'éviter les oscillations numériques, une équation d'état non-linéaire est utilisée:

\[
    P_i =  k \left (\left ( \frac{\rho_i}{\rho_0}\right )^\gamma - 1 \right )
\]

avec:

\begin{itemize}
    \item \(\rho_0\): la densité au repos (exemple: 1000kg/m\(^2\) pour l'eau)
    \item \(k\): constante de raideur (pressureCoefficient)
    \item \(\gamma\): exposan (souvent entre 5 et 7, ici fixé à 7)
\end{itemize}

Ce modèle évite les pressions négatives et assurre une réponse plus fluide à la compression.

On pourrait se dire puisque notre fluide est ``incompréssible'' que il ne devrait pas avoir de différence entre \(\rho_0\) et \(\rho_i\), mais nous faisons une simulations, au long terme le fluide agi de manière incompréssible en agissant contre la pression, mais ce n'est pas instantanné.

\subsubsection{Force de pression}

La force de pression exercée sur une particule \(i\) est calculée par

\[
    \vec{f_i}^\text{pression} = - \sum_j m_j \left ( \frac{P_i + P_j}{2\rho_j}\right ) \grad W(\norm{\vec{r_i} - \vec{r_j}}, h)
\]

Ce terme assure la répulsion entre les paricules trop proches et la cohésion du fluide.

\subsubsection{Viscosité}

Un terme de viscosité artificielle permet de modéliser l'amortissement des vitesses relatives et d'éviter les artéfacts numériques, ce terme est nécessaire dû à notre méthode de résolution d'équation différentiel (notre ``intégrateur''), en calculant l'état suivant à partir de l'état actuel, l'énergie à tendance à se créer à cause des erreurs numériques (et en calculant l'état suivant selon comment on calculerait l'état précédent pour être celui actuel, l'énergie à tendance à se perdre, créant de soi une viscosité qu'on aurait à réduire, des approches complexes existent, tel que les intégrateurs {\emph {simpléctiques}} qui intégres en restant sur la surface d'un {\emph {simplexe}}, obtenu avec les équations Hamiltoniennes de la méchaniques, mais ce sujet bien qu'intéressant et source d'amélioration n'a pas sa place à être trop développer ici). Ce terme est donné par:

\[
    \vec{f_i}^\text{viscosité} = \mu \sum_j m_j \left ( \frac{\vec{v_j} + \vec{v_i}}{\rho_j}\right ) \grad W(\norm{\vec{r_i} - \vec{r_j}}, h)
\]

où \(\mu\) est le coefficient de viscosité propre au fluide.

\subsubsection{Force externe}

Une force de gravité est aussi appliquer à chaque particules:

\[
    \vec{f_i}^\text{gravité} = m_i \vec{g}
\]

\section{Le projet}

\subsection{Pre-Unity: Le choix de rust}

Nous (surtout Jacques) avons commencé avec de (trop) grandes ambitions sur le setup du projet.

\begin{itemize}
    \item le faire en {\emph {rust}} pour avoir des très bonnes performances.
    \item implementer le build avec {\emph {nix}} pour une gestion automatique de {\emph {toutes}} dépendences (incluant obtenir rust, pour avoir la même version, le même système pour nous tous) avec {\emph {crane}}.
    \item une gestions de faille de sécurités par un repot d'audit de packets, analyseur statique d'appelle insécure en temps qu'option de base d'utiliser crane!
    \item pouvoir faire du cross-platform, et compiler notre code rust dans le CI pour plusieurs architectures et OS.
    \item utiliser {\emph {nom}}, une librairies rust de grandeurs physiques, qui nous permettrait d'enlever tout bug correspondant à mélanger des éléments de grandeurs différents (qui sont forcément des bugs, car dépendant du choix exacte de grandeur)
\end{itemize}

Des questions se sont poser sur comment faire une fenêtre en rust, il y a très loins qu'une seule option, les deux idées prédominantes ont été d'utiliser la librairie {\emph {bevy}} ou {\emph {SDL2}} (proposition de Jacques, ayant un peu d'expérience en SDL2 dans d'autres langages (C)) ou de manière plus bas niveau, {\emph {wgpu}} (proposition de Stéphane).

De manière merveilleuse, on n'aurait même pas à gerer l'installation de SDL2 grâce à nix! Et lier la librairie statiquement aurait fait que il n'y aurait pas eu besoin pour les utilisateur•ices d'installer quoi que ce soit, juste l'executable.

Mais il y a eu des mais, essayer de setup le cross-platform était vraiment frustrant, trop frustrant, je ne l'ai au final pas fait, il aurait fallu à mes camarades d'installer nix, et sans utilier du caching, crane demandait trop souvent de réinstaller les dépendances, ce qui est long! Et même sans les demande d'installation de dépendances, il n'y avait pas le caching usuel fait par {\emph {cargo}} le build system de rust de base, tout était recompiler depuis la source au lieu de compiler une fois, puis utiliser des objets compilé. Ce qui a rendu l'utilisation encore plus lente que normalement. Chaque modification prenait des minutes, ce qui tue assez rapidement toutes joies ou volonté de programmer, donc l'utilisation de nix a été abandonné, avec lui, les perspectives d'utiliser SDL2.

Nous avons tous de notre côté ensuite essayer de faire marche bery ou wgpu, mais bevy utilise un modèle assez spéciale, {\emph ECS} (Entity Component System) qui paraîssait pas très naturel et n'était pas le but de ce projet, et wgpu était trop bas niveau.

Ce fut trop, on n'avancait pas, malgrè les qualités techniques, si on ne peut pas intéragir rapidement avec notre projet, il est plus difficile d'expérimenter, voir ce qui marche, etc., le choix était plus nuancé que prévu, nous avons donc abandonné rust pour avoir quelque chose qui règlait notre plus grand problème, le graphique, ainsi nous avons utilisé Unity ensuite.

\subsection{Post-Rust : Unity}
TODO

\section{Conclusion}
TODO
\end{document}
